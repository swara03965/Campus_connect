export default [{"exports":["S","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x"],"facadeModuleId":null,"isDynamicEntry":false,"isEntry":false,"isImplicitEntry":false,"modules":{"/home/bmccann/src/sapper/node_modules/svelte/internal/index.mjs":{"originalLength":52067,"removedExports":["HtmlTag","SvelteComponentDev","SvelteElement","action_destroyer","add_attribute","add_classes","add_flush_callback","add_location","add_resize_listener","add_transform","append_dev","attr_dev","beforeUpdate","bind","bubble","clear_loops","component_subscribe","compute_rest_props","createEventDispatcher","create_animation","create_bidirectional_transition","create_in_transition","create_out_transition","create_ssr_component","custom_event","dataset_dev","debug","destroy_block","destroy_each","detach_after_dev","detach_before_dev","detach_between_dev","detach_dev","dispatch_dev","each","element_is","escape","escaped","exclude_internal_props","fix_and_destroy_block","fix_and_outro_and_destroy_block","fix_position","getContext","get_binding_group_value","get_store_value","globals","handle_promise","has_prop","identity","insert_dev","intros","invalid_attribute_name_character","is_client","is_crossorigin","is_promise","listen","listen_dev","loop","loop_guard","missing_component","not_equal","now","null_to_empty","object_without_properties","onDestroy","once","outro_and_destroy_block","prevent_default","prop_dev","query_selector_all","raf","select_multiple_value","select_option","select_options","select_value","self","set_attributes","set_custom_element_data","set_data","set_data_dev","set_input_type","set_input_value","set_now","set_raf","set_store_value","set_style","set_svg_attributes","spread","stop_propagation","subscribe","tick","time_ranges_to_array","to_number","toggle_class","update_keyed_each","validate_component","validate_each_argument","validate_each_keys","validate_slots","validate_store","xlink_attr"],"renderedExports":["SvelteComponent","add_render_callback","afterUpdate","append","assign","attr","binding_callbacks","blank_object","check_outros","children","claim_component","claim_element","claim_space","claim_text","create_component","create_slot","current_component","destroy_component","detach","dirty_components","element","empty","flush","get_current_component","get_slot_changes","get_slot_context","get_spread_object","get_spread_update","group_outros","init","insert","is_empty","is_function","mount_component","noop","onMount","run","run_all","safe_not_equal","schedule_update","setContext","set_current_component","space","svg_element","text","transition_in","transition_out","update_slot"],"renderedLength":12066},"/home/bmccann/src/sapper/node_modules/svelte/store/index.mjs":{"originalLength":3298,"removedExports":["derived","readable"],"renderedExports":["writable"],"renderedLength":1683},"/home/bmccann/src/sapper/test/apps/css/src/node_modules/@sapper/internal/shared.mjs":{"originalLength":108,"removedExports":["preload"],"renderedExports":["CONTEXT_KEY"],"renderedLength":23},"/home/bmccann/src/sapper/test/apps/css/src/node_modules/@sapper/internal/layout.svelte":{"originalLength":13,"removedExports":[],"renderedExports":["default"],"renderedLength":1369},"/home/bmccann/src/sapper/test/apps/css/src/routes/_error.css":{"originalLength":426,"removedExports":[],"renderedExports":[],"renderedLength":0},"/home/bmccann/src/sapper/test/apps/css/src/routes/_error.svelte":{"originalLength":75,"removedExports":[],"renderedExports":["default"],"renderedLength":788},"/home/bmccann/src/sapper/test/apps/css/src/node_modules/@sapper/internal/App.svelte":{"originalLength":652,"removedExports":[],"renderedExports":["default"],"renderedLength":7619},"/home/bmccann/src/sapper/test/apps/css/src/node_modules/@sapper/internal/manifest-client.mjs":{"originalLength":1097,"removedExports":[],"renderedExports":["root_comp","ignore","components","routes"],"renderedLength":848},"/home/bmccann/src/sapper/test/apps/css/src/node_modules/@sapper/app.mjs":{"originalLength":18855,"removedExports":["stores"],"renderedExports":["goto","prefetch","prefetchRoutes","start"],"renderedLength":18450},"/home/bmccann/src/sapper/test/apps/css/src/client.js":{"originalLength":268,"removedExports":[],"renderedExports":[],"renderedLength":200}},"name":"client","type":"chunk","code":"function noop() { }\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            const remove = [];\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j++];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            for (let k = 0; k < remove.length; k++) {\n                node.removeAttribute(remove[k]);\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(`Function called outside component initialization`);\n    return current_component;\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\n\nconst dirty_components = [];\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const prop_values = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, prop_values, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nconst subscriber_queue = [];\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = [];\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (let i = 0; i < subscribers.length; i += 1) {\n                    const s = subscribers[i];\n                    s[1]();\n                    subscriber_queue.push(s, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.push(subscriber);\n        if (subscribers.length === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index !== -1) {\n                subscribers.splice(index, 1);\n            }\n            if (subscribers.length === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\n\nconst CONTEXT_KEY = {};\n\n/* test/apps/css/src/node_modules/@sapper/internal/layout.svelte generated by Svelte v3.24.1 */\n\nfunction create_fragment(ctx) {\n\tlet current;\n\tconst default_slot_template = /*$$slots*/ ctx[1].default;\n\tconst default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);\n\n\treturn {\n\t\tc() {\n\t\t\tif (default_slot) default_slot.c();\n\t\t},\n\t\tl(nodes) {\n\t\t\tif (default_slot) default_slot.l(nodes);\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tif (default_slot) {\n\t\t\t\tdefault_slot.m(target, anchor);\n\t\t\t}\n\n\t\t\tcurrent = true;\n\t\t},\n\t\tp(ctx, [dirty]) {\n\t\t\tif (default_slot) {\n\t\t\t\tif (default_slot.p && dirty & /*$$scope*/ 1) {\n\t\t\t\t\tupdate_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\ttransition_in(default_slot, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\ttransition_out(default_slot, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tif (default_slot) default_slot.d(detaching);\n\t\t}\n\t};\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet { $$slots = {}, $$scope } = $$props;\n\n\t$$self.$$set = $$props => {\n\t\tif (\"$$scope\" in $$props) $$invalidate(0, $$scope = $$props.$$scope);\n\t};\n\n\treturn [$$scope, $$slots];\n}\n\nclass Layout extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\t\tinit(this, options, instance, create_fragment, safe_not_equal, {});\n\t}\n}\n\nvar root_comp = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    'default': Layout\n});\n\n/* test/apps/css/src/routes/_error.svelte generated by Svelte v3.24.1 */\n\nfunction create_fragment$1(ctx) {\n\tlet h1;\n\tlet t;\n\n\treturn {\n\t\tc() {\n\t\t\th1 = element(\"h1\");\n\t\t\tt = text(\"This is an error page\");\n\t\t\tthis.h();\n\t\t},\n\t\tl(nodes) {\n\t\t\th1 = claim_element(nodes, \"H1\", { class: true });\n\t\t\tvar h1_nodes = children(h1);\n\t\t\tt = claim_text(h1_nodes, \"This is an error page\");\n\t\t\th1_nodes.forEach(detach);\n\t\t\tthis.h();\n\t\t},\n\t\th() {\n\t\t\tattr(h1, \"class\", \"svelte-i7qo5m\");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tinsert(target, h1, anchor);\n\t\t\tappend(h1, t);\n\t\t},\n\t\tp: noop,\n\t\ti: noop,\n\t\to: noop,\n\t\td(detaching) {\n\t\t\tif (detaching) detach(h1);\n\t\t}\n\t};\n}\n\nclass Error$1 extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\t\tinit(this, options, null, create_fragment$1, safe_not_equal, {});\n\t}\n}\n\n/* test/apps/css/src/node_modules/@sapper/internal/App.svelte generated by Svelte v3.24.1 */\n\nfunction create_else_block(ctx) {\n\tlet switch_instance;\n\tlet switch_instance_anchor;\n\tlet current;\n\tconst switch_instance_spread_levels = [/*level1*/ ctx[4].props];\n\tvar switch_value = /*level1*/ ctx[4].component;\n\n\tfunction switch_props(ctx) {\n\t\tlet switch_instance_props = {};\n\n\t\tfor (let i = 0; i < switch_instance_spread_levels.length; i += 1) {\n\t\t\tswitch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);\n\t\t}\n\n\t\treturn { props: switch_instance_props };\n\t}\n\n\tif (switch_value) {\n\t\tswitch_instance = new switch_value(switch_props());\n\t}\n\n\treturn {\n\t\tc() {\n\t\t\tif (switch_instance) create_component(switch_instance.$$.fragment);\n\t\t\tswitch_instance_anchor = empty();\n\t\t},\n\t\tl(nodes) {\n\t\t\tif (switch_instance) claim_component(switch_instance.$$.fragment, nodes);\n\t\t\tswitch_instance_anchor = empty();\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tif (switch_instance) {\n\t\t\t\tmount_component(switch_instance, target, anchor);\n\t\t\t}\n\n\t\t\tinsert(target, switch_instance_anchor, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp(ctx, dirty) {\n\t\t\tconst switch_instance_changes = (dirty & /*level1*/ 16)\n\t\t\t? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*level1*/ ctx[4].props)])\n\t\t\t: {};\n\n\t\t\tif (switch_value !== (switch_value = /*level1*/ ctx[4].component)) {\n\t\t\t\tif (switch_instance) {\n\t\t\t\t\tgroup_outros();\n\t\t\t\t\tconst old_component = switch_instance;\n\n\t\t\t\t\ttransition_out(old_component.$$.fragment, 1, 0, () => {\n\t\t\t\t\t\tdestroy_component(old_component, 1);\n\t\t\t\t\t});\n\n\t\t\t\t\tcheck_outros();\n\t\t\t\t}\n\n\t\t\t\tif (switch_value) {\n\t\t\t\t\tswitch_instance = new switch_value(switch_props());\n\t\t\t\t\tcreate_component(switch_instance.$$.fragment);\n\t\t\t\t\ttransition_in(switch_instance.$$.fragment, 1);\n\t\t\t\t\tmount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);\n\t\t\t\t} else {\n\t\t\t\t\tswitch_instance = null;\n\t\t\t\t}\n\t\t\t} else if (switch_value) {\n\t\t\t\tswitch_instance.$set(switch_instance_changes);\n\t\t\t}\n\t\t},\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\tif (switch_instance) transition_in(switch_instance.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\tif (switch_instance) transition_out(switch_instance.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tif (detaching) detach(switch_instance_anchor);\n\t\t\tif (switch_instance) destroy_component(switch_instance, detaching);\n\t\t}\n\t};\n}\n\n// (21:1) {#if error}\nfunction create_if_block(ctx) {\n\tlet error_1;\n\tlet current;\n\n\terror_1 = new Error$1({\n\t\t\tprops: {\n\t\t\t\terror: /*error*/ ctx[0],\n\t\t\t\tstatus: /*status*/ ctx[1]\n\t\t\t}\n\t\t});\n\n\treturn {\n\t\tc() {\n\t\t\tcreate_component(error_1.$$.fragment);\n\t\t},\n\t\tl(nodes) {\n\t\t\tclaim_component(error_1.$$.fragment, nodes);\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tmount_component(error_1, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp(ctx, dirty) {\n\t\t\tconst error_1_changes = {};\n\t\t\tif (dirty & /*error*/ 1) error_1_changes.error = /*error*/ ctx[0];\n\t\t\tif (dirty & /*status*/ 2) error_1_changes.status = /*status*/ ctx[1];\n\t\t\terror_1.$set(error_1_changes);\n\t\t},\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\ttransition_in(error_1.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\ttransition_out(error_1.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tdestroy_component(error_1, detaching);\n\t\t}\n\t};\n}\n\n// (20:0) <Layout segment=\"{segments[0]}\" {...level0.props}>\nfunction create_default_slot(ctx) {\n\tlet current_block_type_index;\n\tlet if_block;\n\tlet if_block_anchor;\n\tlet current;\n\tconst if_block_creators = [create_if_block, create_else_block];\n\tconst if_blocks = [];\n\n\tfunction select_block_type(ctx, dirty) {\n\t\tif (/*error*/ ctx[0]) return 0;\n\t\treturn 1;\n\t}\n\n\tcurrent_block_type_index = select_block_type(ctx);\n\tif_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n\n\treturn {\n\t\tc() {\n\t\t\tif_block.c();\n\t\t\tif_block_anchor = empty();\n\t\t},\n\t\tl(nodes) {\n\t\t\tif_block.l(nodes);\n\t\t\tif_block_anchor = empty();\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tif_blocks[current_block_type_index].m(target, anchor);\n\t\t\tinsert(target, if_block_anchor, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp(ctx, dirty) {\n\t\t\tlet previous_block_index = current_block_type_index;\n\t\t\tcurrent_block_type_index = select_block_type(ctx);\n\n\t\t\tif (current_block_type_index === previous_block_index) {\n\t\t\t\tif_blocks[current_block_type_index].p(ctx, dirty);\n\t\t\t} else {\n\t\t\t\tgroup_outros();\n\n\t\t\t\ttransition_out(if_blocks[previous_block_index], 1, 1, () => {\n\t\t\t\t\tif_blocks[previous_block_index] = null;\n\t\t\t\t});\n\n\t\t\t\tcheck_outros();\n\t\t\t\tif_block = if_blocks[current_block_type_index];\n\n\t\t\t\tif (!if_block) {\n\t\t\t\t\tif_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n\t\t\t\t\tif_block.c();\n\t\t\t\t}\n\n\t\t\t\ttransition_in(if_block, 1);\n\t\t\t\tif_block.m(if_block_anchor.parentNode, if_block_anchor);\n\t\t\t}\n\t\t},\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\ttransition_in(if_block);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\ttransition_out(if_block);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tif_blocks[current_block_type_index].d(detaching);\n\t\t\tif (detaching) detach(if_block_anchor);\n\t\t}\n\t};\n}\n\nfunction create_fragment$2(ctx) {\n\tlet layout;\n\tlet current;\n\tconst layout_spread_levels = [{ segment: /*segments*/ ctx[2][0] }, /*level0*/ ctx[3].props];\n\n\tlet layout_props = {\n\t\t$$slots: { default: [create_default_slot] },\n\t\t$$scope: { ctx }\n\t};\n\n\tfor (let i = 0; i < layout_spread_levels.length; i += 1) {\n\t\tlayout_props = assign(layout_props, layout_spread_levels[i]);\n\t}\n\n\tlayout = new Layout({ props: layout_props });\n\n\treturn {\n\t\tc() {\n\t\t\tcreate_component(layout.$$.fragment);\n\t\t},\n\t\tl(nodes) {\n\t\t\tclaim_component(layout.$$.fragment, nodes);\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tmount_component(layout, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp(ctx, [dirty]) {\n\t\t\tconst layout_changes = (dirty & /*segments, level0*/ 12)\n\t\t\t? get_spread_update(layout_spread_levels, [\n\t\t\t\t\tdirty & /*segments*/ 4 && { segment: /*segments*/ ctx[2][0] },\n\t\t\t\t\tdirty & /*level0*/ 8 && get_spread_object(/*level0*/ ctx[3].props)\n\t\t\t\t])\n\t\t\t: {};\n\n\t\t\tif (dirty & /*$$scope, error, status, level1*/ 147) {\n\t\t\t\tlayout_changes.$$scope = { dirty, ctx };\n\t\t\t}\n\n\t\t\tlayout.$set(layout_changes);\n\t\t},\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\ttransition_in(layout.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\ttransition_out(layout.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tdestroy_component(layout, detaching);\n\t\t}\n\t};\n}\n\nfunction instance$1($$self, $$props, $$invalidate) {\n\tlet { stores } = $$props;\n\tlet { error } = $$props;\n\tlet { status } = $$props;\n\tlet { segments } = $$props;\n\tlet { level0 } = $$props;\n\tlet { level1 = null } = $$props;\n\tlet { notify } = $$props;\n\tafterUpdate(notify);\n\tsetContext(CONTEXT_KEY, stores);\n\n\t$$self.$$set = $$props => {\n\t\tif (\"stores\" in $$props) $$invalidate(5, stores = $$props.stores);\n\t\tif (\"error\" in $$props) $$invalidate(0, error = $$props.error);\n\t\tif (\"status\" in $$props) $$invalidate(1, status = $$props.status);\n\t\tif (\"segments\" in $$props) $$invalidate(2, segments = $$props.segments);\n\t\tif (\"level0\" in $$props) $$invalidate(3, level0 = $$props.level0);\n\t\tif (\"level1\" in $$props) $$invalidate(4, level1 = $$props.level1);\n\t\tif (\"notify\" in $$props) $$invalidate(6, notify = $$props.notify);\n\t};\n\n\treturn [error, status, segments, level0, level1, stores, notify];\n}\n\nclass App extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\n\t\tinit(this, options, instance$1, create_fragment$2, safe_not_equal, {\n\t\t\tstores: 5,\n\t\t\terror: 0,\n\t\t\tstatus: 1,\n\t\t\tsegments: 2,\n\t\t\tlevel0: 3,\n\t\t\tlevel1: 4,\n\t\t\tnotify: 6\n\t\t});\n\t}\n}\n\n// This file is generated by Sapper — do not edit it!\n\nconst ignore = [];\n\nconst components = [\n\t{\n\t\tjs: () => import('./index.505fa251.js'),\n\t\tcss: \"__SAPPER_CSS_PLACEHOLDER:index.svelte__\"\n\t},\n\t{\n\t\tjs: () => import('./index2.6686907b.js'),\n\t\tcss: \"__SAPPER_CSS_PLACEHOLDER:index2.svelte__\"\n\t},\n\t{\n\t\tjs: () => import('./bar.a5e6278b.js'),\n\t\tcss: \"__SAPPER_CSS_PLACEHOLDER:bar.svelte__\"\n\t},\n\t{\n\t\tjs: () => import('./foo.a7c0de36.js'),\n\t\tcss: \"__SAPPER_CSS_PLACEHOLDER:foo.svelte__\"\n\t}\n];\n\nconst routes = [\n\t{\n\t\t// index.svelte\n\t\tpattern: /^\\/$/,\n\t\tparts: [\n\t\t\t{ i: 0 }\n\t\t]\n\t},\n\n\t{\n\t\t// index2.svelte\n\t\tpattern: /^\\/index2\\/?$/,\n\t\tparts: [\n\t\t\t{ i: 1 }\n\t\t]\n\t},\n\n\t{\n\t\t// bar.svelte\n\t\tpattern: /^\\/bar\\/?$/,\n\t\tparts: [\n\t\t\t{ i: 2 }\n\t\t]\n\t},\n\n\t{\n\t\t// foo.svelte\n\t\tpattern: /^\\/foo\\/?$/,\n\t\tparts: [\n\t\t\t{ i: 3 }\n\t\t]\n\t}\n];\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nfunction goto(href, opts = { noscroll: false, replaceState: false }) {\r\n    const target = select_target(new URL(href, document.baseURI));\r\n    if (target) {\r\n        _history[opts.replaceState ? 'replaceState' : 'pushState']({ id: cid }, '', href);\r\n        return navigate(target, null, opts.noscroll).then(() => { });\r\n    }\r\n    location.href = href;\r\n    return new Promise(f => { }); // never resolves\r\n}\n\nfunction page_store(value) {\r\n    const store = writable(value);\r\n    let ready = true;\r\n    function notify() {\r\n        ready = true;\r\n        store.update(val => val);\r\n    }\r\n    function set(new_value) {\r\n        ready = false;\r\n        store.set(new_value);\r\n    }\r\n    function subscribe(run) {\r\n        let old_value;\r\n        return store.subscribe((new_value) => {\r\n            if (old_value === undefined || (ready && new_value !== old_value)) {\r\n                run(old_value = new_value);\r\n            }\r\n        });\r\n    }\r\n    return { notify, set, subscribe };\r\n}\n\nconst initial_data = typeof __SAPPER__ !== 'undefined' && __SAPPER__;\r\nlet ready = false;\r\nlet root_component;\r\nlet current_token;\r\nlet root_preloaded;\r\nlet current_branch = [];\r\nlet current_query = '{}';\r\nconst stores = {\r\n    page: page_store({}),\r\n    preloading: writable(null),\r\n    session: writable(initial_data && initial_data.session)\r\n};\r\nlet $session;\r\nlet session_dirty;\r\nstores.session.subscribe((value) => __awaiter(void 0, void 0, void 0, function* () {\r\n    $session = value;\r\n    if (!ready)\r\n        return;\r\n    session_dirty = true;\r\n    const dest = select_target(new URL(location.href));\r\n    const token = current_token = {};\r\n    const { redirect, props, branch } = yield hydrate_target(dest);\r\n    if (token !== current_token)\r\n        return; // a secondary navigation happened while we were loading\r\n    if (redirect) {\r\n        yield goto(redirect.location, { replaceState: true });\r\n    }\r\n    else {\r\n        yield render(branch, props, dest.page);\r\n    }\r\n}));\r\nlet prefetching = null;\r\nfunction set_prefetching(href, promise) {\r\n    prefetching = { href, promise };\r\n}\r\nlet target;\r\nfunction set_target(element) {\r\n    target = element;\r\n}\r\nlet uid = 1;\r\nfunction set_uid(n) {\r\n    uid = n;\r\n}\r\nlet cid;\r\nfunction set_cid(n) {\r\n    cid = n;\r\n}\r\nconst _history = typeof history !== 'undefined' ? history : {\r\n    pushState: (state, title, href) => { },\r\n    replaceState: (state, title, href) => { },\r\n    scrollRestoration: ''\r\n};\r\nconst scroll_history = {};\r\nfunction extract_query(search) {\r\n    const query = Object.create(null);\r\n    if (search.length > 0) {\r\n        search.slice(1).split('&').forEach(searchParam => {\r\n            const [, key, value = ''] = /([^=]*)(?:=(.*))?/.exec(decodeURIComponent(searchParam.replace(/\\+/g, ' ')));\r\n            if (typeof query[key] === 'string')\r\n                query[key] = [query[key]];\r\n            if (typeof query[key] === 'object')\r\n                query[key].push(value);\r\n            else\r\n                query[key] = value;\r\n        });\r\n    }\r\n    return query;\r\n}\r\nfunction select_target(url) {\r\n    if (url.origin !== location.origin)\r\n        return null;\r\n    if (!url.pathname.startsWith(initial_data.baseUrl))\r\n        return null;\r\n    let path = url.pathname.slice(initial_data.baseUrl.length);\r\n    if (path === '') {\r\n        path = '/';\r\n    }\r\n    // avoid accidental clashes between server routes and page routes\r\n    if (ignore.some(pattern => pattern.test(path)))\r\n        return;\r\n    for (let i = 0; i < routes.length; i += 1) {\r\n        const route = routes[i];\r\n        const match = route.pattern.exec(path);\r\n        if (match) {\r\n            const query = extract_query(url.search);\r\n            const part = route.parts[route.parts.length - 1];\r\n            const params = part.params ? part.params(match) : {};\r\n            const page = { host: location.host, path, query, params };\r\n            return { href: url.href, route, match, page };\r\n        }\r\n    }\r\n}\r\nfunction handle_error(url) {\r\n    const { host, pathname, search } = location;\r\n    const { session, preloaded, status, error } = initial_data;\r\n    if (!root_preloaded) {\r\n        root_preloaded = preloaded && preloaded[0];\r\n    }\r\n    const props = {\r\n        error,\r\n        status,\r\n        session,\r\n        level0: {\r\n            props: root_preloaded\r\n        },\r\n        level1: {\r\n            props: {\r\n                status,\r\n                error\r\n            },\r\n            component: Error$1\r\n        },\r\n        segments: preloaded\r\n    };\r\n    const query = extract_query(search);\r\n    render([], props, { host, path: pathname, query, params: {} });\r\n}\r\nfunction scroll_state() {\r\n    return {\r\n        x: pageXOffset,\r\n        y: pageYOffset\r\n    };\r\n}\r\nfunction navigate(dest, id, noscroll, hash) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (id) {\r\n            // popstate or initial navigation\r\n            cid = id;\r\n        }\r\n        else {\r\n            const current_scroll = scroll_state();\r\n            // clicked on a link. preserve scroll state\r\n            scroll_history[cid] = current_scroll;\r\n            id = cid = ++uid;\r\n            scroll_history[cid] = noscroll ? current_scroll : { x: 0, y: 0 };\r\n        }\r\n        cid = id;\r\n        if (root_component)\r\n            stores.preloading.set(true);\r\n        const loaded = prefetching && prefetching.href === dest.href ?\r\n            prefetching.promise :\r\n            hydrate_target(dest);\r\n        prefetching = null;\r\n        const token = current_token = {};\r\n        const loaded_result = yield loaded;\r\n        const { redirect } = loaded_result;\r\n        if (token !== current_token)\r\n            return; // a secondary navigation happened while we were loading\r\n        if (redirect) {\r\n            yield goto(redirect.location, { replaceState: true });\r\n        }\r\n        else {\r\n            const { props, branch } = loaded_result;\r\n            yield render(branch, props, dest.page);\r\n        }\r\n        if (document.activeElement && (document.activeElement instanceof HTMLElement))\r\n            document.activeElement.blur();\r\n        if (!noscroll) {\r\n            let scroll = scroll_history[id];\r\n            if (hash) {\r\n                // scroll is an element id (from a hash), we need to compute y.\r\n                const deep_linked = document.getElementById(hash.slice(1));\r\n                if (deep_linked) {\r\n                    scroll = {\r\n                        x: 0,\r\n                        y: deep_linked.getBoundingClientRect().top + scrollY\r\n                    };\r\n                }\r\n            }\r\n            scroll_history[cid] = scroll;\r\n            if (scroll) {\r\n                redirect ? scrollTo(0, 0) : scrollTo(scroll.x, scroll.y);\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction render(branch, props, page) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        stores.page.set(page);\r\n        stores.preloading.set(false);\r\n        if (root_component) {\r\n            root_component.$set(props);\r\n        }\r\n        else {\r\n            props.stores = {\r\n                page: { subscribe: stores.page.subscribe },\r\n                preloading: { subscribe: stores.preloading.subscribe },\r\n                session: stores.session\r\n            };\r\n            props.level0 = {\r\n                props: yield root_preloaded\r\n            };\r\n            props.notify = stores.page.notify;\r\n            root_component = new App({\r\n                target,\r\n                props,\r\n                hydrate: true\r\n            });\r\n        }\r\n        current_branch = branch;\r\n        current_query = JSON.stringify(page.query);\r\n        ready = true;\r\n        session_dirty = false;\r\n    });\r\n}\r\nfunction part_changed(i, segment, match, stringified_query) {\r\n    // TODO only check query string changes for preload functions\r\n    // that do in fact depend on it (using static analysis or\r\n    // runtime instrumentation)\r\n    if (stringified_query !== current_query)\r\n        return true;\r\n    const previous = current_branch[i];\r\n    if (!previous)\r\n        return false;\r\n    if (segment !== previous.segment)\r\n        return true;\r\n    if (previous.match) {\r\n        if (JSON.stringify(previous.match.slice(1, i + 2)) !== JSON.stringify(match.slice(1, i + 2))) {\r\n            return true;\r\n        }\r\n    }\r\n}\r\nfunction hydrate_target(dest) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const { route, page } = dest;\r\n        const segments = page.path.split('/').filter(Boolean);\r\n        let redirect = null;\r\n        const props = { error: null, status: 200, segments: [segments[0]] };\r\n        const preload_context = {\r\n            fetch: (url, opts) => fetch(url, opts),\r\n            redirect: (statusCode, location) => {\r\n                if (redirect && (redirect.statusCode !== statusCode || redirect.location !== location)) {\r\n                    throw new Error(`Conflicting redirects`);\r\n                }\r\n                redirect = { statusCode, location };\r\n            },\r\n            error: (status, error) => {\r\n                props.error = typeof error === 'string' ? new Error(error) : error;\r\n                props.status = status;\r\n            }\r\n        };\r\n        if (!root_preloaded) {\r\n            const root_preload = undefined || (() => { });\r\n            root_preloaded = initial_data.preloaded[0] || root_preload.call(preload_context, {\r\n                host: page.host,\r\n                path: page.path,\r\n                query: page.query,\r\n                params: {}\r\n            }, $session);\r\n        }\r\n        let branch;\r\n        let l = 1;\r\n        try {\r\n            const stringified_query = JSON.stringify(page.query);\r\n            const match = route.pattern.exec(page.path);\r\n            let segment_dirty = false;\r\n            branch = yield Promise.all(route.parts.map((part, i) => __awaiter(this, void 0, void 0, function* () {\r\n                const segment = segments[i];\r\n                if (part_changed(i, segment, match, stringified_query))\r\n                    segment_dirty = true;\r\n                props.segments[l] = segments[i + 1]; // TODO make this less confusing\r\n                if (!part)\r\n                    return { segment };\r\n                const j = l++;\r\n                if (!session_dirty && !segment_dirty && current_branch[i] && current_branch[i].part === part.i) {\r\n                    return current_branch[i];\r\n                }\r\n                segment_dirty = false;\r\n                const { default: component, preload } = yield load_component(components[part.i]);\r\n                let preloaded;\r\n                if (ready || !initial_data.preloaded[i + 1]) {\r\n                    preloaded = preload\r\n                        ? yield preload.call(preload_context, {\r\n                            host: page.host,\r\n                            path: page.path,\r\n                            query: page.query,\r\n                            params: part.params ? part.params(dest.match) : {}\r\n                        }, $session)\r\n                        : {};\r\n                }\r\n                else {\r\n                    preloaded = initial_data.preloaded[i + 1];\r\n                }\r\n                return (props[`level${j}`] = { component, props: preloaded, segment, match, part: part.i });\r\n            })));\r\n        }\r\n        catch (error) {\r\n            props.error = error;\r\n            props.status = 500;\r\n            branch = [];\r\n        }\r\n        return { redirect, props, branch };\r\n    });\r\n}\r\nfunction load_css(chunk) {\r\n    const href = `client/${chunk}`;\r\n    if (document.querySelector(`link[href=\"${href}\"]`))\r\n        return;\r\n    return new Promise((fulfil, reject) => {\r\n        const link = document.createElement('link');\r\n        link.rel = 'stylesheet';\r\n        link.href = href;\r\n        link.onload = () => fulfil();\r\n        link.onerror = reject;\r\n        document.head.appendChild(link);\r\n    });\r\n}\r\nfunction load_component(component) {\r\n    // TODO this is temporary — once placeholders are\r\n    // always rewritten, scratch the ternary\r\n    const promises = (typeof component.css === 'string' ? [] : component.css.map(load_css));\r\n    promises.unshift(component.js());\r\n    return Promise.all(promises).then(values => values[0]);\r\n}\n\nfunction prefetch(href) {\r\n    const target = select_target(new URL(href, document.baseURI));\r\n    if (target) {\r\n        if (!prefetching || href !== prefetching.href) {\r\n            set_prefetching(href, hydrate_target(target));\r\n        }\r\n        return prefetching.promise;\r\n    }\r\n}\n\nfunction start(opts) {\r\n    if ('scrollRestoration' in _history) {\r\n        _history.scrollRestoration = 'manual';\r\n    }\r\n    // Adopted from Nuxt.js\r\n    // Reset scrollRestoration to auto when leaving page, allowing page reload\r\n    // and back-navigation from other pages to use the browser to restore the\r\n    // scrolling position.\r\n    addEventListener('beforeunload', () => {\r\n        _history.scrollRestoration = 'auto';\r\n    });\r\n    // Setting scrollRestoration to manual again when returning to this page.\r\n    addEventListener('load', () => {\r\n        _history.scrollRestoration = 'manual';\r\n    });\r\n    set_target(opts.target);\r\n    addEventListener('click', handle_click);\r\n    addEventListener('popstate', handle_popstate);\r\n    // prefetch\r\n    addEventListener('touchstart', trigger_prefetch);\r\n    addEventListener('mousemove', handle_mousemove);\r\n    return Promise.resolve().then(() => {\r\n        const { hash, href } = location;\r\n        _history.replaceState({ id: uid }, '', href);\r\n        const url = new URL(location.href);\r\n        if (initial_data.error)\r\n            return handle_error();\r\n        const target = select_target(url);\r\n        if (target)\r\n            return navigate(target, uid, true, hash);\r\n    });\r\n}\r\nlet mousemove_timeout;\r\nfunction handle_mousemove(event) {\r\n    clearTimeout(mousemove_timeout);\r\n    mousemove_timeout = setTimeout(() => {\r\n        trigger_prefetch(event);\r\n    }, 20);\r\n}\r\nfunction trigger_prefetch(event) {\r\n    const a = find_anchor(event.target);\r\n    if (!a || a.rel !== 'prefetch')\r\n        return;\r\n    prefetch(a.href);\r\n}\r\nfunction handle_click(event) {\r\n    // Adapted from https://github.com/visionmedia/page.js\r\n    // MIT license https://github.com/visionmedia/page.js#license\r\n    if (which(event) !== 1)\r\n        return;\r\n    if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey)\r\n        return;\r\n    if (event.defaultPrevented)\r\n        return;\r\n    const a = find_anchor(event.target);\r\n    if (!a)\r\n        return;\r\n    if (!a.href)\r\n        return;\r\n    // check if link is inside an svg\r\n    // in this case, both href and target are always inside an object\r\n    const svg = typeof a.href === 'object' && a.href.constructor.name === 'SVGAnimatedString';\r\n    const href = String(svg ? a.href.baseVal : a.href);\r\n    if (href === location.href) {\r\n        if (!location.hash)\r\n            event.preventDefault();\r\n        return;\r\n    }\r\n    // Ignore if tag has\r\n    // 1. 'download' attribute\r\n    // 2. rel='external' attribute\r\n    if (a.hasAttribute('download') || a.getAttribute('rel') === 'external')\r\n        return;\r\n    // Ignore if <a> has a target\r\n    if (svg ? a.target.baseVal : a.target)\r\n        return;\r\n    const url = new URL(href);\r\n    // Don't handle hash changes\r\n    if (url.pathname === location.pathname && url.search === location.search)\r\n        return;\r\n    const target = select_target(url);\r\n    if (target) {\r\n        const noscroll = a.hasAttribute('sapper:noscroll');\r\n        navigate(target, null, noscroll, url.hash);\r\n        event.preventDefault();\r\n        _history.pushState({ id: cid }, '', url.href);\r\n    }\r\n}\r\nfunction which(event) {\r\n    return event.which === null ? event.button : event.which;\r\n}\r\nfunction find_anchor(node) {\r\n    while (node && node.nodeName.toUpperCase() !== 'A')\r\n        node = node.parentNode; // SVG <a> elements have a lowercase name\r\n    return node;\r\n}\r\nfunction handle_popstate(event) {\r\n    scroll_history[cid] = scroll_state();\r\n    if (event.state) {\r\n        const url = new URL(location.href);\r\n        const target = select_target(url);\r\n        if (target) {\r\n            navigate(target, event.state.id);\r\n        }\r\n        else {\r\n            // eslint-disable-next-line\r\n            location.href = location.href; // nosonar\r\n        }\r\n    }\r\n    else {\r\n        // hashchange\r\n        set_uid(uid + 1);\r\n        set_cid(uid);\r\n        _history.replaceState({ id: cid }, '', location.href);\r\n    }\r\n}\n\nfunction prefetchRoutes(pathnames) {\r\n    return routes\r\n        .filter(pathnames\r\n        ? route => pathnames.some(pathname => route.pattern.test(pathname))\r\n        : () => true)\r\n        .reduce((promise, route) => promise.then(() => {\r\n        return Promise.all(route.parts.map(part => part && load_component(components[part.i])));\r\n    }), Promise.resolve());\r\n}\n\nwindow.start = () => start({\n\ttarget: document.querySelector('#sapper')\n});\n\nwindow.prefetchRoutes = () => prefetchRoutes();\nwindow.prefetch = href => prefetch(href);\nwindow.goto = href => goto(href);\n\nexport { SvelteComponent as S, space as a, children as b, claim_element as c, claim_text as d, element as e, detach as f, claim_space as g, attr as h, init as i, insert as j, append as k, create_component as l, claim_component as m, noop as n, mount_component as o, transition_in as p, transition_out as q, destroy_component as r, safe_not_equal as s, text as t, empty as u, check_outros as v, onMount as w, group_outros as x };\n","dynamicImports":["index.505fa251.js","index2.6686907b.js","bar.a5e6278b.js","foo.a7c0de36.js"],"fileName":"client.8dfa4ebc.js","implicitlyLoadedBefore":[],"imports":[],"map":null,"referencedFiles":[]},{"exports":["default"],"facadeModuleId":"/home/bmccann/src/sapper/test/apps/css/src/routes/index.svelte","isDynamicEntry":true,"isEntry":false,"isImplicitEntry":false,"modules":{"/home/bmccann/src/sapper/test/apps/css/src/routes/index.css":{"originalLength":475,"removedExports":[],"renderedExports":[],"renderedLength":0},"/home/bmccann/src/sapper/test/apps/css/src/routes/index.svelte":{"originalLength":109,"removedExports":[],"renderedExports":["default"],"renderedLength":1638}},"name":"index","type":"chunk","code":"import { S as SvelteComponent, i as init, s as safe_not_equal, e as element, t as text, a as space, c as claim_element, b as children, d as claim_text, f as detach, g as claim_space, h as attr, j as insert, k as append, n as noop } from './client.8dfa4ebc.js';\n\n/* test/apps/css/src/routes/index.svelte generated by Svelte v3.24.1 */\n\nfunction create_fragment(ctx) {\n\tlet h1;\n\tlet t0;\n\tlet t1;\n\tlet a0;\n\tlet t2;\n\tlet t3;\n\tlet a1;\n\tlet t4;\n\n\treturn {\n\t\tc() {\n\t\t\th1 = element(\"h1\");\n\t\t\tt0 = text(\"Great success!\");\n\t\t\tt1 = space();\n\t\t\ta0 = element(\"a\");\n\t\t\tt2 = text(\"foo\");\n\t\t\tt3 = space();\n\t\t\ta1 = element(\"a\");\n\t\t\tt4 = text(\"bar\");\n\t\t\tthis.h();\n\t\t},\n\t\tl(nodes) {\n\t\t\th1 = claim_element(nodes, \"H1\", { class: true });\n\t\t\tvar h1_nodes = children(h1);\n\t\t\tt0 = claim_text(h1_nodes, \"Great success!\");\n\t\t\th1_nodes.forEach(detach);\n\t\t\tt1 = claim_space(nodes);\n\t\t\ta0 = claim_element(nodes, \"A\", { href: true });\n\t\t\tvar a0_nodes = children(a0);\n\t\t\tt2 = claim_text(a0_nodes, \"foo\");\n\t\t\ta0_nodes.forEach(detach);\n\t\t\tt3 = claim_space(nodes);\n\t\t\ta1 = claim_element(nodes, \"A\", { href: true });\n\t\t\tvar a1_nodes = children(a1);\n\t\t\tt4 = claim_text(a1_nodes, \"bar\");\n\t\t\ta1_nodes.forEach(detach);\n\t\t\tthis.h();\n\t\t},\n\t\th() {\n\t\t\tattr(h1, \"class\", \"svelte-bt9zrl\");\n\t\t\tattr(a0, \"href\", \"foo\");\n\t\t\tattr(a1, \"href\", \"bar\");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tinsert(target, h1, anchor);\n\t\t\tappend(h1, t0);\n\t\t\tinsert(target, t1, anchor);\n\t\t\tinsert(target, a0, anchor);\n\t\t\tappend(a0, t2);\n\t\t\tinsert(target, t3, anchor);\n\t\t\tinsert(target, a1, anchor);\n\t\t\tappend(a1, t4);\n\t\t},\n\t\tp: noop,\n\t\ti: noop,\n\t\to: noop,\n\t\td(detaching) {\n\t\t\tif (detaching) detach(h1);\n\t\t\tif (detaching) detach(t1);\n\t\t\tif (detaching) detach(a0);\n\t\t\tif (detaching) detach(t3);\n\t\t\tif (detaching) detach(a1);\n\t\t}\n\t};\n}\n\nclass Routes extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\t\tinit(this, options, null, create_fragment, safe_not_equal, {});\n\t}\n}\n\nexport default Routes;\n","dynamicImports":[],"fileName":"index.505fa251.js","implicitlyLoadedBefore":[],"imports":["client.8dfa4ebc.js"],"map":null,"referencedFiles":[]},{"exports":["default"],"facadeModuleId":"/home/bmccann/src/sapper/test/apps/css/src/routes/index2.svelte","isDynamicEntry":true,"isEntry":false,"isImplicitEntry":false,"modules":{"/home/bmccann/src/sapper/test/apps/css/src/routes/index2.svelte":{"originalLength":69,"removedExports":[],"renderedExports":["default"],"renderedLength":785}},"name":"index2","type":"chunk","code":"import { S as SvelteComponent, i as init, s as safe_not_equal, l as create_component, m as claim_component, o as mount_component, n as noop, p as transition_in, q as transition_out, r as destroy_component } from './client.8dfa4ebc.js';\nimport Routes from './index.505fa251.js';\n\n/* test/apps/css/src/routes/index2.svelte generated by Svelte v3.24.1 */\n\nfunction create_fragment(ctx) {\n\tlet index;\n\tlet current;\n\tindex = new Routes({});\n\n\treturn {\n\t\tc() {\n\t\t\tcreate_component(index.$$.fragment);\n\t\t},\n\t\tl(nodes) {\n\t\t\tclaim_component(index.$$.fragment, nodes);\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tmount_component(index, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: noop,\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\ttransition_in(index.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\ttransition_out(index.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tdestroy_component(index, detaching);\n\t\t}\n\t};\n}\n\nclass Index2 extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\t\tinit(this, options, null, create_fragment, safe_not_equal, {});\n\t}\n}\n\nexport default Index2;\n","dynamicImports":[],"fileName":"index2.6686907b.js","implicitlyLoadedBefore":[],"imports":["client.8dfa4ebc.js","index.505fa251.js"],"map":null,"referencedFiles":[]},{"exports":["default"],"facadeModuleId":"/home/bmccann/src/sapper/test/apps/css/src/routes/bar.svelte","isDynamicEntry":true,"isEntry":false,"isImplicitEntry":false,"modules":{"/home/bmccann/src/sapper/test/apps/css/src/routes/bar.svelte":{"originalLength":213,"removedExports":[],"renderedExports":["default"],"renderedLength":2311}},"name":"bar","type":"chunk","code":"import { S as SvelteComponent, i as init, s as safe_not_equal, l as create_component, u as empty, m as claim_component, o as mount_component, j as insert, q as transition_out, v as check_outros, p as transition_in, f as detach, r as destroy_component, w as onMount, x as group_outros } from './client.8dfa4ebc.js';\n\n/* test/apps/css/src/routes/bar.svelte generated by Svelte v3.24.1 */\n\nfunction create_fragment(ctx) {\n\tlet switch_instance;\n\tlet switch_instance_anchor;\n\tlet current;\n\tvar switch_value = /*Title*/ ctx[0];\n\n\tfunction switch_props(ctx) {\n\t\treturn {};\n\t}\n\n\tif (switch_value) {\n\t\tswitch_instance = new switch_value(switch_props());\n\t}\n\n\treturn {\n\t\tc() {\n\t\t\tif (switch_instance) create_component(switch_instance.$$.fragment);\n\t\t\tswitch_instance_anchor = empty();\n\t\t},\n\t\tl(nodes) {\n\t\t\tif (switch_instance) claim_component(switch_instance.$$.fragment, nodes);\n\t\t\tswitch_instance_anchor = empty();\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tif (switch_instance) {\n\t\t\t\tmount_component(switch_instance, target, anchor);\n\t\t\t}\n\n\t\t\tinsert(target, switch_instance_anchor, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp(ctx, [dirty]) {\n\t\t\tif (switch_value !== (switch_value = /*Title*/ ctx[0])) {\n\t\t\t\tif (switch_instance) {\n\t\t\t\t\tgroup_outros();\n\t\t\t\t\tconst old_component = switch_instance;\n\n\t\t\t\t\ttransition_out(old_component.$$.fragment, 1, 0, () => {\n\t\t\t\t\t\tdestroy_component(old_component, 1);\n\t\t\t\t\t});\n\n\t\t\t\t\tcheck_outros();\n\t\t\t\t}\n\n\t\t\t\tif (switch_value) {\n\t\t\t\t\tswitch_instance = new switch_value(switch_props());\n\t\t\t\t\tcreate_component(switch_instance.$$.fragment);\n\t\t\t\t\ttransition_in(switch_instance.$$.fragment, 1);\n\t\t\t\t\tmount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);\n\t\t\t\t} else {\n\t\t\t\t\tswitch_instance = null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\tif (switch_instance) transition_in(switch_instance.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\tif (switch_instance) transition_out(switch_instance.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tif (detaching) detach(switch_instance_anchor);\n\t\t\tif (switch_instance) destroy_component(switch_instance, detaching);\n\t\t}\n\t};\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet { Title } = $$props;\n\n\tonMount(() => {\n\t\timport('./Title.cb1086b7.js').then(mod => {\n\t\t\t$$invalidate(0, Title = mod.default);\n\t\t});\n\t});\n\n\t$$self.$$set = $$props => {\n\t\tif (\"Title\" in $$props) $$invalidate(0, Title = $$props.Title);\n\t};\n\n\treturn [Title];\n}\n\nclass Bar extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\t\tinit(this, options, instance, create_fragment, safe_not_equal, { Title: 0 });\n\t}\n}\n\nexport default Bar;\n","dynamicImports":["Title.cb1086b7.js"],"fileName":"bar.a5e6278b.js","implicitlyLoadedBefore":[],"imports":["client.8dfa4ebc.js"],"map":null,"referencedFiles":[]},{"exports":["default"],"facadeModuleId":"/home/bmccann/src/sapper/test/apps/css/src/routes/foo.svelte","isDynamicEntry":true,"isEntry":false,"isImplicitEntry":false,"modules":{"/home/bmccann/src/sapper/test/apps/css/src/routes/foo.css":{"originalLength":389,"removedExports":[],"renderedExports":[],"renderedLength":0},"/home/bmccann/src/sapper/test/apps/css/src/routes/foo.svelte":{"originalLength":54,"removedExports":[],"renderedExports":["default"],"renderedLength":742}},"name":"foo","type":"chunk","code":"import { S as SvelteComponent, i as init, s as safe_not_equal, e as element, t as text, c as claim_element, b as children, d as claim_text, f as detach, h as attr, j as insert, k as append, n as noop } from './client.8dfa4ebc.js';\n\n/* test/apps/css/src/routes/foo.svelte generated by Svelte v3.24.1 */\n\nfunction create_fragment(ctx) {\n\tlet h1;\n\tlet t;\n\n\treturn {\n\t\tc() {\n\t\t\th1 = element(\"h1\");\n\t\t\tt = text(\"Foo\");\n\t\t\tthis.h();\n\t\t},\n\t\tl(nodes) {\n\t\t\th1 = claim_element(nodes, \"H1\", { class: true });\n\t\t\tvar h1_nodes = children(h1);\n\t\t\tt = claim_text(h1_nodes, \"Foo\");\n\t\t\th1_nodes.forEach(detach);\n\t\t\tthis.h();\n\t\t},\n\t\th() {\n\t\t\tattr(h1, \"class\", \"svelte-1x1ajbk\");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tinsert(target, h1, anchor);\n\t\t\tappend(h1, t);\n\t\t},\n\t\tp: noop,\n\t\ti: noop,\n\t\to: noop,\n\t\td(detaching) {\n\t\t\tif (detaching) detach(h1);\n\t\t}\n\t};\n}\n\nclass Foo extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\t\tinit(this, options, null, create_fragment, safe_not_equal, {});\n\t}\n}\n\nexport default Foo;\n","dynamicImports":[],"fileName":"foo.a7c0de36.js","implicitlyLoadedBefore":[],"imports":["client.8dfa4ebc.js"],"map":null,"referencedFiles":[]},{"exports":["default"],"facadeModuleId":"/home/bmccann/src/sapper/test/apps/css/src/routes/_components/Title.svelte","isDynamicEntry":true,"isEntry":false,"isImplicitEntry":false,"modules":{"/home/bmccann/src/sapper/test/apps/css/src/routes/_components/Title.css":{"originalLength":397,"removedExports":[],"renderedExports":[],"renderedLength":0},"/home/bmccann/src/sapper/test/apps/css/src/routes/_components/Title.svelte":{"originalLength":57,"removedExports":[],"renderedExports":["default"],"renderedLength":761}},"name":"Title","type":"chunk","code":"import { S as SvelteComponent, i as init, s as safe_not_equal, e as element, t as text, c as claim_element, b as children, d as claim_text, f as detach, h as attr, j as insert, k as append, n as noop } from './client.8dfa4ebc.js';\n\n/* test/apps/css/src/routes/_components/Title.svelte generated by Svelte v3.24.1 */\n\nfunction create_fragment(ctx) {\n\tlet h1;\n\tlet t;\n\n\treturn {\n\t\tc() {\n\t\t\th1 = element(\"h1\");\n\t\t\tt = text(\"Title\");\n\t\t\tthis.h();\n\t\t},\n\t\tl(nodes) {\n\t\t\th1 = claim_element(nodes, \"H1\", { class: true });\n\t\t\tvar h1_nodes = children(h1);\n\t\t\tt = claim_text(h1_nodes, \"Title\");\n\t\t\th1_nodes.forEach(detach);\n\t\t\tthis.h();\n\t\t},\n\t\th() {\n\t\t\tattr(h1, \"class\", \"svelte-yhusah\");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tinsert(target, h1, anchor);\n\t\t\tappend(h1, t);\n\t\t},\n\t\tp: noop,\n\t\ti: noop,\n\t\to: noop,\n\t\td(detaching) {\n\t\t\tif (detaching) detach(h1);\n\t\t}\n\t};\n}\n\nclass Title extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\t\tinit(this, options, null, create_fragment, safe_not_equal, {});\n\t}\n}\n\nexport default Title;\n","dynamicImports":[],"fileName":"Title.cb1086b7.js","implicitlyLoadedBefore":[],"imports":["client.8dfa4ebc.js"],"map":null,"referencedFiles":[]},{"exports":[],"facadeModuleId":"/home/bmccann/src/sapper/test/apps/css/src/client.js","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"modules":{},"name":"client","type":"chunk","code":"import './client.8dfa4ebc.js';\n","dynamicImports":[],"fileName":"client.420f1edd.js","implicitlyLoadedBefore":[],"imports":["client.8dfa4ebc.js"],"map":null,"referencedFiles":[]}]